/*
 1．面向对象的三大特征是什么？
    封装
        函数，就是1个封装的体现
        类，就是更高级别的封装，类将数据和行为封装为一个整体。
        好处：
        -> 屏蔽内部实现。外界不需要知道内部是如何实现的 只需要知道这个对象有什么用.
        -> 方便操作.
        -> 后期的维护十分的便利.
    继承
    多态
 
 2. 存在的问题
    就是为对象的属性赋值的时候 语法上其实只要数据的类型是属性的类型就是可以的.但是，情理上这么做是不合的。
 
    就像Person对象有1个int类型的属性_age 表示1个人的年龄.
    为这个对象的_age属性赋值的时候 其实只要是int类型的数据 语法上都是完全可以的，
    但是1个人的年龄 正常情况下是在 0-200之间的.
 
    解决的问题：
    在为对象的属性赋值的时候，我希望将这个数据做1个逻辑验证．
    如果属性赋的值在这个逻辑范围之内 那么我们就把这个值赋值给属性.否则我们就做默认处理.
 
    就像我们希望为Person对象的_age属性赋值的时候，要判断1下为_age属性赋的值是不是在0-200之内，
    否则我们就做默认处理。
 
 3.如何实现这个需求
    1）．将属性的@public去掉.因为一旦写上@public就意味着外界可以直接访问对象的这个属性.
        外界一旦可以直接访问这个属性 那么外界就可以任意的这个属性赋值 这个时候你拦都拦不住.
 
        去掉@public 外界就无法直接访问这个属性 也就无法赋值了．
 
    2）. 为类提供1个方法，这个方法专门为这个属性赋值，这个方法我们叫做setter
 
        a．这个方法一定是1个对象方法 因为这个要为属性赋值.
        b. 这个方法没有返回值，因为这个方法做的事情 仅仅是为属性赋值就可以了.
        C.这个方法的名称必须以set开头，跟上去掉下划线首字母大写的属性名.
        d.这个方法一定是有参数的，参数的类型和属性的类型一致，参数的名称和属性的名称一致（去掉下划线）
        e.在方法的实现中，判断传入的数据是否符合逻辑。如果符合逻辑则赋值 否则做默认处理。
        f.外界想要为对象的属性赋值 那么就调用这个对象的setter方法 将要赋值的数据传入给这个方法.
            方法会对这个数据进行验证 如果符合验证 就会吧数据赋值给属性 否则就会做默认处理.
 
    3）．这么一写，我们确实可以在为对象的属性赋值的时候做1个逻辑验证了．
        但是问题就是 在外界无法取出属性的值了，
        那就再写1个方法，专门用来返回属性的值.这个方法我们叫做getter方法.
 
        a.这个方法一定是1个对象方法 因为这个方法做的事情是拿到属性的值返回.
        b. 这个方法肯定有返回值 返回值的类型和属性的类型一致.
        C. 这个方法的名称直接就是属性的名称（去掉下划线的）
        d. 这个方法没有参数
        e.这个方法的实现是直接将属性的值返回.
        f. 这个时候，如果外界希望得到属性的值.那么就只需要调用这个getter方法就可以了.
 
 5．什么时候需要为属性封装setter和getter？
 
    1）.只要属性需要被外界访问，就要这个属性封装setter和getter。
        哪怕在赋值或者取值的时候没有任何逻辑验证.
    2）. 如果属性只在类的内部访问，那么就不需要为其封装getter setter
 
 6．只读封装与只写封装。
    只读封装：为属性封装的时候 只提供getter 不提供setter
    只写封装：为属性封装的时候 只提供setter 不提供getter
 */

#import <Foundation/Foundation.h>
#include "Person.h"

int main(int argc, const char * argv[]) {
    Person *p1 = [Person new];
    
    [p1 setName:@"张三"];
    [p1 setAge:99];
    [p1 sayHi];
    
    return 0;
}
